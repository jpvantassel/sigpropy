%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{SigProPy}
\date{Nov 08, 2019}
\release{0.0.1}
\author{Joseph P.\@{} Vantassel}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


SigProPy is a digital signal processing module for python. The module includes
two main classes a TimeSeries and FourierTransform class. These classes include
various methods for creating and manipulating time series and fourier transforms.


\chapter{TimeSeries Class}
\label{\detokenize{index:timeseries-class}}
This file contains the class TimeSeries for creating and manipulating
time series objects.


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{TimeSeries}}}{\emph{amplitude}, \emph{dt}, \emph{nstacks=1}, \emph{delay=0}}{}
A class for editing and manipulating time series.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{amp: np.array}] \leavevmode
Denotes the time series amplitude. If amp is 1d each sample
corresponds to a single time step. If amp is 2d each row 
corresponds to a particular section of the time record 
(i.e., time window) and each column corresponds to a single
time step.

\item[{dt: float }] \leavevmode
Denotes the time step between samples in seconds.

\item[{n\_windows}] \leavevmode{[}int{]}
Number of time windows that the time series has been split
into (i.e., number of rows of amp if 2d).

\item[{n\_samples}] \leavevmode{[}int{]}
Number of samples in time series (i.e., \sphinxtitleref{len(amp)} if \sphinxtitleref{amp}
is 1d or number of columns if \sphinxtitleref{amp} is 2d).

\item[{fs}] \leavevmode{[}float{]}
Sampling frequency in Hz equal to \sphinxtitleref{1/dt}.

\item[{fny}] \leavevmode{[}float{]}
Nyquist frequency in Hz equal to \sphinxtitleref{fs/2}.

\end{description}

\end{description}


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bandpassfilter}}}{\emph{flow}, \emph{fhigh}, \emph{order=5}}{}
Bandpass filter TimeSeries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{flow: float}] \leavevmode
Low cut-off frequency for filter (content below flow is 
filtered).

\item[{fhigh: float}] \leavevmode
High cut-off frequency for filter (content above fhigh is
filtered).

\item[{order: int}] \leavevmode
Filter order

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, perform filter operation on attribute \sphinxtitleref{amp}.

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{check\_input}}}{\emph{name}, \emph{values}}{}
Perform simple checks on values of parameter \sphinxtitleref{name}.
\begin{description}
\item[{Specifically:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxtitleref{values} is \sphinxtitleref{ndarray}, \sphinxtitleref{list}, or \sphinxtitleref{tuple}.

\item {} 
If \sphinxtitleref{list} or \sphinxtitleref{tuple} convert to a \sphinxtitleref{ndarray}.

\item {} 
Check \sphinxtitleref{values} is one-dimensional \sphinxtitleref{ndarray}.

\end{enumerate}

\item[{Args:}] \leavevmode\begin{description}
\item[{name}] \leavevmode{[}str{]}
\sphinxtitleref{name} of parameter to be check. Only used to raise 
easily understood exceptions.

\item[{values}] \leavevmode{[}any{]}
value of parameter to be checked.

\end{description}

\item[{Returns:}] \leavevmode
\sphinxtitleref{values} as an \sphinxtitleref{ndarray}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{TypeError}] \leavevmode
If entries do not comply with checks 1. and 2. listed 
above.

\end{description}

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cosine\_taper}}}{\emph{width}}{}
Apply cosine taper to TimeSeries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{width}] \leavevmode{[}float \{0.-1.\} {]}
Amount of the TimeSeries to be tapered. 0 represents a 
rectangular window and 1 a Hann window.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead applies cosine taper to attribute
\sphinxtitleref{amp}.

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_trace}}}{\emph{trace}, \emph{nstacks=1}, \emph{delay=0}}{}
Initialize a TimeSeries object from a trace object.

This method is a more general method than from\_trace\_seg2, which
does not attempt to extract anything from the trace object 
except for its data and sampling step.
\begin{description}
\item[{Args:}] \leavevmode
trace: Trace object.
\begin{description}
\item[{nstacks: Integer representing the number of stacks. Default }] \leavevmode
value is one (i.e., only a single recording was made).

\item[{delay: Number that is less than or equal to zero, denoting}] \leavevmode
the pre-trigger delay. Default value is zero (i.e., no
pre-trigger delay was recorded).

\end{description}

\item[{Returns:}] \leavevmode
Initialized TimeSeries object.

\item[{Raises:}] \leavevmode
This method raises no exceptions.

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{windowlength}}{}
Split TimeSeries into windows of length windowlength.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{windowlength}] \leavevmode{[}int{]}
Integer defining length of window in seconds. If 
\sphinxtitleref{windowlength} is not integer multiple of dt, the 
window length is rounded to up to the next integer
multiple of dt.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, reshapes attribute \sphinxtitleref{amp} into a 2D array 
where each row is a different consecutive time window and 
each column denotes a time step.

\item[{Note:}] \leavevmode
The last sample of each window is repeated as the first
sample of the following time window to ensure a logical
number of windows. Without this a 10 minute record could
not be broken into 10 1-minute records.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sigpropy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{amp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{TimeSeries}\PYG{p}{(}\PYG{n}{amp}\PYG{p}{,} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries}\PYG{o}{.}\PYG{n}{amp}
\PYG{g+go}{array([[0, 1, 2],}
\PYG{g+go}{    [2, 3, 4],}
\PYG{g+go}{    [4, 5, 6],}
\PYG{g+go}{    [6, 7, 8]])}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{time}}}
Return time vector for TimeSeries object.

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trim}}}{\emph{start\_time}, \emph{end\_time}}{}
Trim excess from TimeSeries object in the half-open interval
{[}start\_time, end\_time).
\begin{description}
\item[{Args: }] \leavevmode\begin{description}
\item[{start\_time}] \leavevmode{[}float{]}
New time zero in seconds.

\item[{end\_time}] \leavevmode{[}float{]}
New end time in seconds. Note that the interval is
half-open.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead updates the attributes: \sphinxtitleref{n\_samples}, 
\sphinxtitleref{delay}, and \sphinxtitleref{df}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{IndexError }] \leavevmode
If the \sphinxtitleref{start\_time} and \sphinxtitleref{end\_time} is illogical.
For example, \sphinxtitleref{start\_time} is before the start of the
\sphinxtitleref{delay} or after \sphinxtitleref{end\_time}, or the \sphinxtitleref{end\_time} is
before the \sphinxtitleref{start\_time} or after the end of the record.

\end{description}

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{zero\_pad}}}{\emph{df=0.2}}{}
Append zeros to the end of the TimeSeries object to achieve a
desired frequency step.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{df}] \leavevmode{[}float{]}
Desired frequency step in Hertz. Must be positive.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead modifies attributes: \sphinxtitleref{amp},
\sphinxtitleref{n\_samples}, and \sphinxtitleref{multiple}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{TypeError}] \leavevmode
If \sphinxtitleref{df} is not a float.

\item[{ValueError}] \leavevmode
If \sphinxtitleref{df} is not positive.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{TimeSeries (class in sigpropy)@\spxentry{TimeSeries}\spxextra{class in sigpropy}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{TimeSeries}}}{\emph{amplitude}, \emph{dt}, \emph{nstacks=1}, \emph{delay=0}}{}
A class for editing and manipulating time series.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{amp: np.array}] \leavevmode
Denotes the time series amplitude. If amp is 1d each sample
corresponds to a single time step. If amp is 2d each row 
corresponds to a particular section of the time record 
(i.e., time window) and each column corresponds to a single
time step.

\item[{dt: float }] \leavevmode
Denotes the time step between samples in seconds.

\item[{n\_windows}] \leavevmode{[}int{]}
Number of time windows that the time series has been split
into (i.e., number of rows of amp if 2d).

\item[{n\_samples}] \leavevmode{[}int{]}
Number of samples in time series (i.e., \sphinxtitleref{len(amp)} if \sphinxtitleref{amp}
is 1d or number of columns if \sphinxtitleref{amp} is 2d).

\item[{fs}] \leavevmode{[}float{]}
Sampling frequency in Hz equal to \sphinxtitleref{1/dt}.

\item[{fny}] \leavevmode{[}float{]}
Nyquist frequency in Hz equal to \sphinxtitleref{fs/2}.

\end{description}

\end{description}
\index{bandpassfilter() (TimeSeries method)@\spxentry{bandpassfilter()}\spxextra{TimeSeries method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.bandpassfilter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bandpassfilter}}}{\emph{flow}, \emph{fhigh}, \emph{order=5}}{}
Bandpass filter TimeSeries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{flow: float}] \leavevmode
Low cut-off frequency for filter (content below flow is 
filtered).

\item[{fhigh: float}] \leavevmode
High cut-off frequency for filter (content above fhigh is
filtered).

\item[{order: int}] \leavevmode
Filter order

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, perform filter operation on attribute \sphinxtitleref{amp}.

\end{description}

\end{fulllineitems}

\index{check\_input() (TimeSeries static method)@\spxentry{check\_input()}\spxextra{TimeSeries static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{check\_input}}}{\emph{name}, \emph{values}}{}
Perform simple checks on values of parameter \sphinxtitleref{name}.
\begin{description}
\item[{Specifically:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxtitleref{values} is \sphinxtitleref{ndarray}, \sphinxtitleref{list}, or \sphinxtitleref{tuple}.

\item {} 
If \sphinxtitleref{list} or \sphinxtitleref{tuple} convert to a \sphinxtitleref{ndarray}.

\item {} 
Check \sphinxtitleref{values} is one-dimensional \sphinxtitleref{ndarray}.

\end{enumerate}

\item[{Args:}] \leavevmode\begin{description}
\item[{name}] \leavevmode{[}str{]}
\sphinxtitleref{name} of parameter to be check. Only used to raise 
easily understood exceptions.

\item[{values}] \leavevmode{[}any{]}
value of parameter to be checked.

\end{description}

\item[{Returns:}] \leavevmode
\sphinxtitleref{values} as an \sphinxtitleref{ndarray}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{TypeError}] \leavevmode
If entries do not comply with checks 1. and 2. listed 
above.

\end{description}

\end{description}

\end{fulllineitems}

\index{cosine\_taper() (TimeSeries method)@\spxentry{cosine\_taper()}\spxextra{TimeSeries method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.cosine_taper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cosine\_taper}}}{\emph{width}}{}
Apply cosine taper to TimeSeries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{width}] \leavevmode{[}float \{0.-1.\} {]}
Amount of the TimeSeries to be tapered. 0 represents a 
rectangular window and 1 a Hann window.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead applies cosine taper to attribute
\sphinxtitleref{amp}.

\end{description}

\end{fulllineitems}

\index{from\_trace() (TimeSeries class method)@\spxentry{from\_trace()}\spxextra{TimeSeries class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.from_trace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_trace}}}{\emph{trace}, \emph{nstacks=1}, \emph{delay=0}}{}
Initialize a TimeSeries object from a trace object.

This method is a more general method than from\_trace\_seg2, which
does not attempt to extract anything from the trace object 
except for its data and sampling step.
\begin{description}
\item[{Args:}] \leavevmode
trace: Trace object.
\begin{description}
\item[{nstacks: Integer representing the number of stacks. Default }] \leavevmode
value is one (i.e., only a single recording was made).

\item[{delay: Number that is less than or equal to zero, denoting}] \leavevmode
the pre-trigger delay. Default value is zero (i.e., no
pre-trigger delay was recorded).

\end{description}

\item[{Returns:}] \leavevmode
Initialized TimeSeries object.

\item[{Raises:}] \leavevmode
This method raises no exceptions.

\end{description}

\end{fulllineitems}

\index{split() (TimeSeries method)@\spxentry{split()}\spxextra{TimeSeries method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.split}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{windowlength}}{}
Split TimeSeries into windows of length windowlength.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{windowlength}] \leavevmode{[}int{]}
Integer defining length of window in seconds. If 
\sphinxtitleref{windowlength} is not integer multiple of dt, the 
window length is rounded to up to the next integer
multiple of dt.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, reshapes attribute \sphinxtitleref{amp} into a 2D array 
where each row is a different consecutive time window and 
each column denotes a time step.

\item[{Note:}] \leavevmode
The last sample of each window is repeated as the first
sample of the following time window to ensure a logical
number of windows. Without this a 10 minute record could
not be broken into 10 1-minute records.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sigpropy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{amp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{TimeSeries}\PYG{p}{(}\PYG{n}{amp}\PYG{p}{,} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tseries}\PYG{o}{.}\PYG{n}{amp}
\PYG{g+go}{array([[0, 1, 2],}
\PYG{g+go}{    [2, 3, 4],}
\PYG{g+go}{    [4, 5, 6],}
\PYG{g+go}{    [6, 7, 8]])}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{time() (TimeSeries property)@\spxentry{time()}\spxextra{TimeSeries property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.time}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{time}}}
Return time vector for TimeSeries object.

\end{fulllineitems}

\index{trim() (TimeSeries method)@\spxentry{trim()}\spxextra{TimeSeries method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.trim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trim}}}{\emph{start\_time}, \emph{end\_time}}{}
Trim excess from TimeSeries object in the half-open interval
{[}start\_time, end\_time).
\begin{description}
\item[{Args: }] \leavevmode\begin{description}
\item[{start\_time}] \leavevmode{[}float{]}
New time zero in seconds.

\item[{end\_time}] \leavevmode{[}float{]}
New end time in seconds. Note that the interval is
half-open.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead updates the attributes: \sphinxtitleref{n\_samples}, 
\sphinxtitleref{delay}, and \sphinxtitleref{df}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{IndexError }] \leavevmode
If the \sphinxtitleref{start\_time} and \sphinxtitleref{end\_time} is illogical.
For example, \sphinxtitleref{start\_time} is before the start of the
\sphinxtitleref{delay} or after \sphinxtitleref{end\_time}, or the \sphinxtitleref{end\_time} is
before the \sphinxtitleref{start\_time} or after the end of the record.

\end{description}

\end{description}

\end{fulllineitems}

\index{zero\_pad() (TimeSeries method)@\spxentry{zero\_pad()}\spxextra{TimeSeries method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.TimeSeries.zero_pad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{zero\_pad}}}{\emph{df=0.2}}{}
Append zeros to the end of the TimeSeries object to achieve a
desired frequency step.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{df}] \leavevmode{[}float{]}
Desired frequency step in Hertz. Must be positive.

\end{description}

\item[{Returns:}] \leavevmode
Returns \sphinxtitleref{None}, instead modifies attributes: \sphinxtitleref{amp},
\sphinxtitleref{n\_samples}, and \sphinxtitleref{multiple}.

\item[{Raises:}] \leavevmode\begin{description}
\item[{TypeError}] \leavevmode
If \sphinxtitleref{df} is not a float.

\item[{ValueError}] \leavevmode
If \sphinxtitleref{df} is not positive.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{FourierTransform Class}
\label{\detokenize{index:fouriertransform-class}}
This file contains the class FourierTransform for creating and 
working with fourier transform objects.


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{FourierTransform}}}{\emph{amplitude}, \emph{frq}, \emph{fnyq=None}}{}
A class for editing and manipulating fourier transforms.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{frq}] \leavevmode{[}np.array{]}
Frequency vector of the transform in Hertz.

\item[{amp}] \leavevmode{[}np.array{]}
The transform’s amplitude in the same units as the input.

\end{description}

\end{description}


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{fft}}}{\emph{amplitude}, \emph{dt}}{}
Compute the fast-fourier transform of a time series.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{amplitude}] \leavevmode{[}np.array{]}
Time series amplitudes (one per time step). Can be a 2D
array where each row is a valid time series.

\item[{dt}] \leavevmode{[}float{]}
Indicating the time step in seconds.

\end{description}

\item[{Returns:}] \leavevmode
Tuple of the form (frq, fft) where:
frq is an np.array containing the positve frequency vector
\begin{quote}

between zero and the nyquist frequency (if even) or near
the nyquist (if odd) in Hertz.
\end{quote}
\begin{description}
\item[{fft is an np.array of complex amplitudes for the frequencies}] \leavevmode
between zero and the nyquist with units of the input 
ampltiude. If \sphinxtitleref{amplitude} is a 2D array \sphinxtitleref{fft} will also 
be a 2D array where each row is the fft of each row of
\sphinxtitleref{amplitude}.

\end{description}

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_timeseries}}}{\emph{timeseries}}{}
Compute the Fast Fourier Transform from a timeseries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{timeseries: TimeSeries }] \leavevmode
TimeSeries object to be transformed.

\end{description}

\item[{Returns:}] \leavevmode
An initialized FourierTransform object.

\end{description}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{imag}}}
Imaginary component of complex fft amplitude.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{mag}}}
Magnitude of complex fft amplitude.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{phase}}}
Phase of complex fft amplitude in radians.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{real}}}
Real component of complex fft amplitude.

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resample}}}{\emph{minf}, \emph{maxf}, \emph{nf}, \emph{res\_type='log'}, \emph{inplace=False}}{}
Resample FourierTransform over a specified range.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{minf}] \leavevmode{[}float {]}
Minimum value of resample.

\item[{maxf}] \leavevmode{[}float{]}
Maximum value or resample.

\item[{nf}] \leavevmode{[}int{]}
Number of resamples.

\item[{res\_type}] \leavevmode{[}\{“log”, “linear”\}{]}
Type of resampling.

\item[{inplace}] \leavevmode{[}bool{]}
Determines whether resampling is done in place or 
if a copy should be returned.

\end{description}

\item[{Returns:}] \leavevmode
If inplace=True, None.

If inplace=False, a tuple of the form (frequency, ) where each parameter is a list.

\item[{Raises:}] \leavevmode\begin{description}
\item[{ValueError}] \leavevmode
If \sphinxtitleref{maxf}, \sphinxtitleref{minf}, or \sphinxtitleref{nf} are illogical.

\item[{NotImplementedError}] \leavevmode
If \sphinxtitleref{res\_type} is not amoung those options specified.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{FourierTransform (class in sigpropy)@\spxentry{FourierTransform}\spxextra{class in sigpropy}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{FourierTransform}}}{\emph{amplitude}, \emph{frq}, \emph{fnyq=None}}{}
A class for editing and manipulating fourier transforms.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{frq}] \leavevmode{[}np.array{]}
Frequency vector of the transform in Hertz.

\item[{amp}] \leavevmode{[}np.array{]}
The transform’s amplitude in the same units as the input.

\end{description}

\end{description}
\index{fft() (FourierTransform static method)@\spxentry{fft()}\spxextra{FourierTransform static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.fft}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{fft}}}{\emph{amplitude}, \emph{dt}}{}
Compute the fast-fourier transform of a time series.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{amplitude}] \leavevmode{[}np.array{]}
Time series amplitudes (one per time step). Can be a 2D
array where each row is a valid time series.

\item[{dt}] \leavevmode{[}float{]}
Indicating the time step in seconds.

\end{description}

\item[{Returns:}] \leavevmode
Tuple of the form (frq, fft) where:
frq is an np.array containing the positve frequency vector
\begin{quote}

between zero and the nyquist frequency (if even) or near
the nyquist (if odd) in Hertz.
\end{quote}
\begin{description}
\item[{fft is an np.array of complex amplitudes for the frequencies}] \leavevmode
between zero and the nyquist with units of the input 
ampltiude. If \sphinxtitleref{amplitude} is a 2D array \sphinxtitleref{fft} will also 
be a 2D array where each row is the fft of each row of
\sphinxtitleref{amplitude}.

\end{description}

\end{description}

\end{fulllineitems}

\index{from\_timeseries() (FourierTransform class method)@\spxentry{from\_timeseries()}\spxextra{FourierTransform class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.from_timeseries}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_timeseries}}}{\emph{timeseries}}{}
Compute the Fast Fourier Transform from a timeseries.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{timeseries: TimeSeries }] \leavevmode
TimeSeries object to be transformed.

\end{description}

\item[{Returns:}] \leavevmode
An initialized FourierTransform object.

\end{description}

\end{fulllineitems}

\index{imag() (FourierTransform property)@\spxentry{imag()}\spxextra{FourierTransform property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.imag}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{imag}}}
Imaginary component of complex fft amplitude.

\end{fulllineitems}

\index{mag() (FourierTransform property)@\spxentry{mag()}\spxextra{FourierTransform property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.mag}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{mag}}}
Magnitude of complex fft amplitude.

\end{fulllineitems}

\index{phase() (FourierTransform property)@\spxentry{phase()}\spxextra{FourierTransform property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.phase}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{phase}}}
Phase of complex fft amplitude in radians.

\end{fulllineitems}

\index{real() (FourierTransform property)@\spxentry{real()}\spxextra{FourierTransform property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.real}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{real}}}
Real component of complex fft amplitude.

\end{fulllineitems}

\index{resample() (FourierTransform method)@\spxentry{resample()}\spxextra{FourierTransform method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sigpropy.FourierTransform.resample}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resample}}}{\emph{minf}, \emph{maxf}, \emph{nf}, \emph{res\_type='log'}, \emph{inplace=False}}{}
Resample FourierTransform over a specified range.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{minf}] \leavevmode{[}float {]}
Minimum value of resample.

\item[{maxf}] \leavevmode{[}float{]}
Maximum value or resample.

\item[{nf}] \leavevmode{[}int{]}
Number of resamples.

\item[{res\_type}] \leavevmode{[}\{“log”, “linear”\}{]}
Type of resampling.

\item[{inplace}] \leavevmode{[}bool{]}
Determines whether resampling is done in place or 
if a copy should be returned.

\end{description}

\item[{Returns:}] \leavevmode
If inplace=True, None.

If inplace=False, a tuple of the form (frequency, ) where each parameter is a list.

\item[{Raises:}] \leavevmode\begin{description}
\item[{ValueError}] \leavevmode
If \sphinxtitleref{maxf}, \sphinxtitleref{minf}, or \sphinxtitleref{nf} are illogical.

\item[{NotImplementedError}] \leavevmode
If \sphinxtitleref{res\_type} is not amoung those options specified.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}